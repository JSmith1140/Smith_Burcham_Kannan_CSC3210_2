<!DOCTYPE html>
<html>
<head>
    <title> CSC3210 Smith_Burcham_Kannan Project 2 </title>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="module">
        import * as THREE from 'three'; // import THREE.js

        const canvas = document.getElementById('myCanvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, canvas.width / canvas.height, 0.1, 3000);
        camera.position.z = 100; // sets camera position
        scene.add(camera); // adds camera to scene

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setClearColor(0xffffff); // sets background color to white
        renderer.setSize(window.innerWidth, window.innerHeight); // sets render size to window dimensions

        // Function to create a random 3D object
        function createRandomObject() {
            let geometryShape;

            const randomShape = Math.floor(Math.random() * 3); // takes a random number between 1 and 3
            if (randomShape == 0) { // if number is 0 create a sphere
                geometryShape = 'sphere';
            } else if (randomShape == 1) { // if number is 1 create a box
                geometryShape = 'box';
            } else { // if number is 2 create a tetrahedron
                geometryShape = 'tetrahedron'; 
            }

            let geometry;
            // takes the output of geometryShape and create the geometry
            if (geometryShape == 'sphere') {
                geometry = new THREE.SphereGeometry(Math.random() + 1, 32, 32); // creates sphere with random radius
            } else if (geometryShape == 'box') {
                geometry = new THREE.BoxGeometry(Math.random() + 1, Math.random() + 1, Math.random() + 1); // creates box with random dimensions
            } else {
                geometry = new THREE.TetrahedronGeometry(Math.random() + 1); // creates tetrahedron with random radius
            }

            const color = Math.random() * 0xffffff; // gives mesh a random color
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);

            // sets the x, y, and z position of the mesh
            mesh.position.x = Math.random() * 200 - 100;
            mesh.position.y = Math.random() * 200 - 100;
            mesh.position.z = Math.random() * 200 - 100;

            return mesh;
        }
        
        const objects = []; // objects array
        for (let i = 0; i < 500; i++) { // creates 500 random 3D objects
            const obj = createRandomObject();
            objects.push(obj);
            scene.add(obj); // add obj to scene
        }

        scene.add(new THREE.AmbientLight(0xffffff)); // adds lighting to show shape colors
        const light = new THREE.DirectionalLight(0xffffff); // adds directional lighting to make shapes appear 3D
				light.position.set(1, 1, 1).normalize();
				scene.add(light); // adds light to the scene

        // Request pointer lock
        function lockPointer() {
            canvas.requestPointerLock();
        }

        canvas.addEventListener('click', lockPointer);

        // Mouse movement event
        let isPointerLocked = false;

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isPointerLocked) return;

            // Update camera rotation based on mouse movement
            camera.rotation.y -= event.movementX * 0.002; // Rotate around Y-axis
            camera.rotation.x -= event.movementY * 0.002; // Rotate around X-axis
        });

        // Move the camera forward with delta time
        const cameraSpeed = 10; // Speed of the camera movement (units per second)

        let lastTime = performance.now(); // Initialize the last time

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now(); // Get the current time
            const deltaTime = (currentTime - lastTime) / 1000; // Calculate delta time in seconds
            lastTime = currentTime; // Update last time

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.normalize();

            // Move the camera based on the delta time
            camera.position.add(forward.multiplyScalar(cameraSpeed * deltaTime));

            const time = Date.now() * 0.001; // calculates time
            objects.forEach((obj) => { // shrinks and grows the object
                const scale = Math.sin(time + obj.position.x) * 0.5 + 1;
                obj.scale.set(scale, scale, scale);
            });
            renderer.render(scene, camera); // render the scene and camera
        }
        animate(); // call animate function
    </script>
</body>
</html>
