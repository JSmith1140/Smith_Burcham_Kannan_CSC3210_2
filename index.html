<!DOCTYPE html>
<html>
<head>
    <title>CSC3210 Smith_Burcham_Kannan Project 2</title>
    <style>
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="module">
        import * as THREE from 'three';

        const canvas = document.getElementById('myCanvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(0, 0, 100); // sets camera position

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setClearColor(0xffffff); // background color is white
        renderer.setSize(window.innerWidth, window.innerHeight);

        const objectSpawn = []; // spawns the objects
        const numObjects = 500; // Number of objects
        const visibilityRange = 100; // Range objects will be visible
        const spawnDistance = 500; // Distance to spawn objects
        const recycleDistance = 200; // distance to recycle objects

        // Function to create a random 3D object
        function createRandomObject() {
            let geometry;
            const randomShape = Math.floor(Math.random() * 3); // takes a random number between 1 and 3

            if (randomShape === 0) { // if number is 0 create a sphere
                geometry = new THREE.SphereGeometry(Math.random() + 1, 32, 32);
            } else if (randomShape === 1) { // if number is 1 create a box
                geometry = new THREE.BoxGeometry(Math.random() + 1, Math.random() + 1, Math.random() + 1);
            } else { // if number is 2 create a tetrahedron
                geometry = new THREE.TetrahedronGeometry(Math.random() + 1);
            }

            const color = Math.random() * 0xffffff; // gives mesh a random color
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);

            return mesh;
        }

        // Creates the "Infinite Objects"
        for (let i = 0; i < numObjects; i++) { // creates a set number of objects that are reused to create infinite effect
            const obj = createRandomObject();
            setRandomPosition(obj);
            objectSpawn.push(obj);
            scene.add(obj); // add obj to scene
        }

        scene.add(new THREE.AmbientLight(0xffffff)); // adds lighting to show shape colors
        const light = new THREE.DirectionalLight(0xffffff); // adds directional lighting to make shapes appear 3D
        light.position.set(1, 1, 1).normalize();
        scene.add(light); // adds light to the scene

        // Sets a random position for the object
        function setRandomPosition(obj) {
            const randomX = Math.random() * 200 - 100; // Random X 
            const randomY = Math.random() * 200 - 100; // Random Y
            const randomZ = camera.position.z - (Math.random() * spawnDistance + visibilityRange); // Random Z

            obj.position.set(randomX, randomY, randomZ);
        }

        // Recycle an object
        function recycleObject(obj) {
            setRandomPosition(obj); // gives new random position for object
        }

        // Request pointer lock
        function lockPointer() {
            canvas.requestPointerLock();
        }

        canvas.addEventListener('click', lockPointer);

        // Mouse movement event
        let isPointerLocked = false;
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isPointerLocked) return;

            // Update camera rotation based on mouse movement
            camera.rotation.y -= event.movementX * 0.002; // Rotate around Y-axis
            camera.rotation.x -= event.movementY * 0.002; // Rotate around X-axis
        });

        // Move the camera forward with delta time
        const cameraSpeed = 10; // Speed of the camera movement (units per second)

        let lastTime = performance.now(); // Initialize the last time

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now(); // Get the current time
            const deltaTime = (currentTime - lastTime) / 1000; // Calculate delta time in seconds
            lastTime = currentTime; // Update last time

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.normalize();

            // Move the camera based on the delta time
            camera.position.add(forward.multiplyScalar(cameraSpeed * deltaTime));

            // Update object positions and recycle them if needed
            objectSpawn.forEach((obj) => {
                obj.position.z += cameraSpeed * deltaTime;

            // Recycle object if it is outside of the camera and recycle distance
            if (obj.position.z > camera.position.z + recycleDistance) {
                recycleObject(obj);
        }
            });
            const time = performance.now() * 0.001; // calculates time
            objectSpawn.forEach((obj) => { // shrinks and grows the object
                const scale = Math.sin(time + obj.position.x) * 0.5 + 1;
                obj.scale.set(scale, scale, scale);
            });


            renderer.render(scene, camera); // Render the scene and camera
        }

        animate(); // Start the animation loop
    </script>
</body>
</html>
